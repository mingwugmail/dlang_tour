#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 1.1 Release (Monday June 16th 2003) [Charlemagne]
Copyright (C), 1994-2003 - INRIA - LORIA - UHP - Nancy 2 - FRANCE
D.COLNET, S.COLLIN, O.ZENDRA, P.RIBET, C.ADRIAN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: -pipe
*/
#ifdef __cplusplus
}
#endif
#include "app.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  Byte swapping function
*/
void copy_swap_16(const uint16_t *src, uint16_t *dest, int count){
  while (count--) {
    *dest++ = (*src << 8) | (*src >> 8);
    src++;
  }
}


/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `realloc' (generated C code is supposed to use
  only `se_realloc' instead of direct `realloc').
*/
void* se_realloc(void* src, size_t size) {
  void *result = realloc(src, size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif !defined(SE_BOOST)
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}
T18 M18={18};

void se_prinT18(FILE* file,T18**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"STD_INPUT_OUTPUT");
fprintf(file,"#%p",(void*)*o);
}
T12 M12={12,NULL,NULL,NULL};

void se_prinT12(FILE* file,T12**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"APP");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"visitor = ");
se_prinT0(file,(T0**)(&((*o)->_visitor)));
fprintf(file,"\n\t  ");
fprintf(file,"bank = ");
se_prinT0(file,(T0**)(&((*o)->_bank)));
fprintf(file,"\n\t  ");
fprintf(file,"doctor = ");
se_prinT0(file,(T0**)(&((*o)->_doctor)));
fprintf(file,"\n\t]");
}
T16 M16={16};

void se_prinT16(FILE* file,T16**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"DOCTOR");
fprintf(file,"#%p",(void*)*o);
}
T7 M7={7,NULL,0,0};
T33 M33={33};

void se_prinT33(FILE* file,T33**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"BANK");
fprintf(file,"#%p",(void*)*o);
}

void se_prinT9(FILE* file,T9*o){
fprintf(file,"NATIVE_ARRAY[CHARACTER]");
fprintf(file,"#%p",(void*)*o);
}
T30 M30={30,NULL,NULL,NULL,NULL};

void se_prinT30(FILE* file,T30**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"VISITOR");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"name = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_name)));
fprintf(file,"\n\t  ");
fprintf(file,"addr = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_addr)));
fprintf(file,"\n\t  ");
fprintf(file,"us_addr = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_us_addr)));
fprintf(file,"\n\t  ");
fprintf(file,"uk_addr = ");
se_prinT7(file,(EIF_STRING*)(&((*o)->_uk_addr)));
fprintf(file,"\n\t]");
}
T27 M27={27,0,NULL,0};

void se_prinT27(FILE* file,T27**o){
if(*o==NULL){
   fprintf(file,"Void");
   return;}
fprintf(file,"STD_OUTPUT");
fprintf(file,"#%p",(void*)*o);
fprintf(file,"\n\t[ ");
fprintf(file,"buffer_position = ");
se_prinT2(file,(&((*o)->_buffer_position)));
fprintf(file,"\n\t  ");
fprintf(file,"buffer = ");
se_prinT9(file,(&((*o)->_buffer)));
fprintf(file,"\n\t  ");
fprintf(file,"capacity = ");
se_prinT2(file,(&((*o)->_capacity)));
fprintf(file,"\n\t]");
}
/*Aliased storage area or unicode storage.*/
char*s16_10="\n";
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/no_check.c) is automatically included
  when `run_control.no_check' is true (ie. all modes except -boost).
*/

/*
   To print object into the trace-stack :
*/
void se_prinT0(FILE* file, T0** o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	fprintf(file,"#%p",(void*)*o);
    }
}

void se_prinT1(FILE* file, EIF_INTEGER_8* o) {
    fprintf(file,"%"PRId8,*o);
}

void se_prinT2(FILE* file, EIF_INTEGER* o) {
    fprintf(file,"%"PRId32,*o);
}

void se_prinT10(FILE* file, EIF_INTEGER_16* o) {
    fprintf(file,"%"PRId16,*o);
}

void se_prinT11(FILE* file,EIF_INTEGER_64* o) {
    fprintf(file,"%"PRId64,*o);
}

static void se_print_character(FILE* file, char c) {
    /* Produce a visible output of `c' using an Eiffelish notation.
     */
    if ((' ' <= c)&&(c <= '~')&&(c != '\'')&&(c != '\"')&&(c != '%')) {
	putc(c,file);
    }
    else {
	switch (c) {
	    case '\b': fprintf(file,"%%B"); break;
	    case '\f': fprintf(file,"%%F"); break;
	    case '\n': fprintf(file,"%%N"); break;
	    case '\r': fprintf(file,"%%R"); break;
	    case '\t': fprintf(file,"%%T"); break;
	    case '\0': fprintf(file,"%%U"); break;
	    case '\'': fprintf(file,"%%\'"); break;
	    case '\"': fprintf(file,"%%\""); break;
	    case '%':  fprintf(file,"%%%%"); break;
	    default:
		fprintf(file,"%%/%d/", (int) ((unsigned char) c));
	}
    }
}

void se_prinT3(FILE* file,EIF_CHARACTER* o) {
    putc('\'',file);
    se_print_character(file, *o);
    putc('\'',file);
}

void se_prinT4(FILE* file, EIF_REAL* o) {
    fprintf(file,"%f",((double)*o));
}

void se_prinT5(FILE* file, EIF_DOUBLE* o) {
    fprintf(file,"%f",*o);
}

void se_prinT6(FILE* file, EIF_BOOLEAN* o) {
    if (*o) {
	fprintf(file,"True");
    }
    else {
	fprintf(file,"False");
    }
}

void se_prinT7(FILE* file, EIF_STRING* o) {
    if (*o == NULL) {
	fprintf(file,"Void");
    }
    else {
	T3* storage = (*o)->_storage;
	int count = (*o)->_count;
	int i = 0;
	putc('\"',file);
	while (i < count) {
	    se_print_character(file, storage[i++]);
	}
	putc('\"',file);
    }
}

void se_prinT8(FILE* file, EIF_POINTER* o) {
    if (*o == NULL) {
	fprintf(file,"NULL");
    }
    else {
	fprintf(file,"POINTER#%p",(void*)*o);
    }
}


#ifndef SCOOP
/*
  The upper most context (SmartEiffel Dump stack Top) :
*/
se_dump_stack* se_dst=NULL;
#endif


int se_stack_size(se_dump_stack* ds) {
  int result = 0;
  while (ds != NULL) {
    ds = ds->caller;
    result ++;
  }
  return result;
}

void se_print_run_time_stack(void) {
  /* GENERAL.print_run_time_stack */

#ifdef SE_SCOOP
  se_subsystem_t* self = se_current_subsystem_thread();
  self->vft.print_run_time_stack(self);
#else
  se_dump_stack* origin;
  se_dump_stack* ds;
  se_dump_stack* ds2;
  int frame_count = 1;
  int rescue = 0;

  origin = se_dst;
  if (origin == NULL) {
    fprintf(SE_ERR,"Empty stack.\n");
    return ;
  }
  else {
    while (origin->exception_origin != NULL) {
      origin = origin->exception_origin;
    }

    ds = origin;
    while (ds->caller != NULL) {
      ds = ds->caller;
      frame_count++;
    }
  }
  fprintf(SE_ERR,"%d frames in current stack.\n",frame_count);
  fprintf(SE_ERR,"=====  Bottom of run-time stack  =====\n");
  while (ds != NULL) {
    se_print_one_frame(ds);
    /* Next frame : */
    if (ds == origin) {
      ds = NULL;
    }
    else if (ds->exception_origin != NULL) {
      rescue = 1;
      ds = ds->exception_origin;
    }
    else {
      ds2 = se_dst;
      while (ds2->caller != ds) {
	ds2 = ds2->caller;
      }
      ds = ds2;
    }
    if (--frame_count) {
      if (!rescue) {
        fprintf(SE_ERR,"======================================\n");
      }
      else {
        fprintf(SE_ERR,"====   Rescue stack  =================\n");
      }
    }
  }
  fprintf(SE_ERR,"=====   Top of run-time stack    =====\n");
#endif /* SE_SCOOP */
}

int se_print_one_frame(se_dump_stack* ds) {
  return se_print_one_frame_in(SE_ERR, ds);
}

int se_print_one_frame_in(FILE* file, se_dump_stack* ds) {
  /* Return 1 for an ordinary frame (not a cecil frame or some dynamic
     dispatch extra frame). */
  se_frame_descriptor* fd = ds->fd;
  int i = 0;
  int local_count = 0;
  char* local_format;
  int expanded;
  int id;
  void** var;

  if (fd == NULL) {
    fprintf(file,"External CECIL call.\n");
    return 0;
  }
  fprintf(file,"%s\n",fd->name);
  if (ds->p == 0) return 0;
  local_format = fd->local_format;
  if (fd->use_current) {
    fprintf(file,"Current = ");
    i = 2;
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    (se_prinT[id])(file, ds->current);
    fprintf(file,"\n");
  }
  while (local_count < fd->local_count) {
    while (local_format[i] != '%') {
      fprintf(file,"%c",local_format[i]);
      i++;
    }
    i++;
    expanded = ((local_format[i++] == 'E')?1:0);
    fprintf(file," = ");
    id = 0;
    while (local_format[i] != '%') {
      id = (id * 10) + (local_format[i] - '0');
      i++;
    }
    i++;
    if (ds->locals == NULL) {
      fprintf(file,"<unavailable>");
    }
    else {
      var = (ds->locals)[local_count];
      if (expanded) {
        (se_prinT[id])(file, (void**)(var));
      }
      else if (*var == NULL) {
        fprintf(file,"Void");
      }
      else {
        (se_prinT[((T0*)(*var))->id])(file, (void**)(var));
      }
    }
    fprintf(file,"\n");
    local_count++;
  }
  fprintf(file,"line %d ",se_position2line(ds->p));
  fflush(file);
  fprintf(file,"column %d ",se_position2column(ds->p));
  fflush(file);
  fprintf(file,"file %s \n",p[se_position2path_id(ds->p)]);
  fflush(file);
  return 1;
}

int se_require_uppermost_flag;

/*
  Require Last Result :
*/
int se_require_last_result;

int se_rci(se_dump_stack*caller,void*C) {
  /* Where `caller' is supposed to be reference type non Void Current
     object. This function return 1 if the class invariant must be
     checked for `C' before leaving the routine.
  */
  if (caller != NULL) {
    se_frame_descriptor* fd = caller->fd;
    if (fd == NULL) {
      /* As for example when coming via CECIL. */
      return 0;
    }
    else {
      if (fd->use_current) {
	if (fd->local_format[1] == 'R') {
	  if (((void*)*(caller->current)) == C) {
	    return 0;
	  }
	}
      }
    }
  }
  return 1;
}

void error0(char* m, char* vv) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  static char*f="*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f,m);
  if (vv!=NULL) fprintf(SE_ERR,f,vv);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,0);
#else
  se_print_run_time_stack();
  fprintf(SE_ERR,f,m);
  if (vv!=NULL)
    fprintf(SE_ERR,f,vv);
  exit(EXIT_FAILURE);
#endif
}

void error1(char*m,se_position position) {
  /* When there is nothing more to do than to exit or to go back
     into the debugger.
  */
  int l = se_position2line(position);
  int c = se_position2column(position);
  int f = se_position2path_id(position);
  char* f1 = "Line : %d column %d in %s.\n";
  char* f2 = "*** Error at Run Time ***: %s\n";

  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
#ifdef SE_EXCEPTIONS
  print_exception();
#endif
#ifdef SE_SEDB
  sedb_break(se_dst,position);
#else
  se_print_run_time_stack();
  fprintf(SE_ERR,f1,l,c,p[f]);
  fprintf(SE_ERR,f2,m);
  exit(EXIT_FAILURE);
#endif
}

void se_print_string(FILE*stream, EIF_STRING s) {
  /* To print some Eiffel STRING. */
  if (s == NULL) {
    fprintf(stream,"Void");
  }
  else {
    int count = s->_count;
    EIF_CHARACTER* storage = s->_storage;
    int i = 0;
    fprintf(stream,"\"");
    while (count != 0) {
      fprintf(stream,"%c",storage[i]);
      i++;
      count--;
    }
    fprintf(stream,"\"");
  }
}

void se_print_bad_target(FILE*stream, int id, T0* o, int l, int c, int f) {
  /* Print Bad Target Type Error Message. */
  if (l != 0) {
    fprintf(stream,"Line : %d column %d in %s.\n",l,c,p[f]);
  }
  fprintf(stream,"*** Error at Run Time *** :\n");
  fprintf(stream,"   Target is not valid (not the good type).\n");
  fprintf(stream,"   Expected: ");
  se_print_string(stream,t[id]);
  fprintf(stream,", Actual: ");
  se_print_string(stream,t[o->id]);
  fprintf(stream,".\n");
}

void error2(T0*o, se_position position) {
  fprintf(SE_ERR,"Target Type ");
  se_print_string(SE_ERR,t[o->id]);
  fprintf(SE_ERR," is not valid.\n");
  error1("Bad target.",position);
}

T0* vc(T0* o, se_position position) {
  /*
    Void check for reference target.
  */
  if (o != NULL) {
    return o;
  }
  else {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Void_call_target);
#else
    error1("Call with a Void target.",position);
#endif
    return NULL;
  }
}

T0* ci(int id, T0* o, se_position position) {
  /*
    Check Id for reference target.
  */
  if ( vc(o,position) != NULL) {
    if ( id == (o->id) ) {
      return o;
    }
    else {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(System_level_type_error);
#else
      int l = se_position2line(position);
      int c = se_position2column(position);
      int f = se_position2path_id(position);

      se_print_bad_target(SE_ERR,id,o,l,c,f);
      se_print_run_time_stack();
      se_print_bad_target(SE_ERR,id,o,l,c,f);
#ifdef SE_SEDB
      sedb_break(se_dst,0);
#else
      exit(EXIT_FAILURE);
#endif
#endif
    }
  }
  return o;
}

void ac_req(int v,char*vv) {
  if (!v && se_require_uppermost_flag) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Precondition);
#else
    error0("Require Assertion Violated.",vv);
#endif
  }
  se_require_last_result=se_require_last_result&&v;
}

void ac_ens(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Postcondition);
#else
    error0("Ensure Assertion Violated.",vv);
#endif
  }
}

void ac_inv(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Class_invariant);
#else
    error0("Class Invariant Violation.",vv);
#endif
  }
}

void ac_liv(int v,char*vv) {
  /* Assertion Check : Loop Invariant check. */
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_invariant);
#else
    error0("Loop Invariant Violation.",vv);
#endif
  }
}

int ac_lvc(int lc,int lv1,int lv2) {
  /* Assertion Check : Loop Variant check. */
  if (lc == 0) {
    if (lv2 < 0) {
#ifdef SE_EXCEPTIONS
      internal_exception_handler(Loop_variant);
#else
      {
	char msg [64];
	sprintf(msg,"Bad First Variant Value = %d\n",lv2);
	error0(msg,NULL);
      }
#endif
    }
    else {
      return lv2;
    }
  }
  else if ((lv2 < 0) || (lv2 >= lv1)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Loop_variant);
#else
    {
      char msg [512];
      sprintf(msg,
	      "Bad loop variant.\nLoop body counter = %d (done)\n"
	      "Previous Variant = %d\nNew Variant = %d\n",
	      lc,lv1,lv2);
      error0(msg,NULL);
    }
#endif
  }
  return lv2;
}

void ac_civ(int v,char*vv) {
  if (!v) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Check_instruction);
#else
    error0("Check Assertion Violated.",vv);
#endif
  }
}

T0* se_evobt(T0* o, se_position position) {
    /*
      Error Void Or Bad Type.
    */
    if (!o) {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(Void_call_target);
#else
	error1("Target is Void.",position);
#endif
    }
    else {
#ifdef SE_EXCEPTIONS
	internal_exception_handler(System_level_type_error);
#else
	error2(o,position);
#endif
    }
    return o; /* Dummy return to avoid C warnings. */
}

void se_signal_handler(int sig) {
  printf("Received signal %d.\n",sig);
#ifdef SE_SEDB
  signal(sig,se_signal_handler);
  sedb_signal_handler(sig);
#else
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
}

void se_gc_check_id(void*o,int id) {
  if (id != (((T0*)o)->id)) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(Routine_failure);
#else
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    se_print_run_time_stack();
    fprintf(SE_ERR,"System-validity error detected during GC cycle.\n");
    se_print_bad_target(SE_ERR,id,(T0*)o,0,0,0);
    exit(EXIT_FAILURE);
#endif
  }
}

se_dump_stack* se_new_dump_stack(se_dump_stack* copy) {
  se_dump_stack* result;
  se_frame_descriptor* fd = copy->fd;
  int i, j, o, p, n;
  int local_count;
  char* local_format;
  int id;
  void** var;
  int local_size;
  int expanded;

  void*** _i;
  void** _ref;
  char*  _exp;

  result = (se_dump_stack*)malloc(sizeof(se_dump_stack));
  if (result != NULL) {
    result->fd               = fd;
    result->p                = copy->p;
    result->caller           = copy->caller;
    result->current          = NULL;
    result->locals           = NULL;
    result->exception_origin = NULL;

    if (fd != NULL) {
      local_format = fd->local_format;
      i = 0;
      if (fd->use_current) {
        result->current = copy->current;
        /* Place i after the Current definition: */
        i = 2;
        id = 0;
        while (local_format[i] != '%') {
          id = (id * 10) + (local_format[i++] - '0');
        }
        i++;
      }

      /*
       *
       * p: sum of the number of pointers ("indirections") per local
       *    -> 1 for an expanded
       *    -> 2 for a reference
       *
       * o: total malloc'ed size
       *
       * _i: access to the first indirection pointer
       *
       * _ref: access to the second indirection pointer of a reference object
       *       _ref == (T0*)(*_i)
       *
       * _exp: access to a copy of the expanded object
       *       _exp == *((char*)_i)
       *
       *
       *
       * For instance, if "0" is the first local, a reference and "4" is the
       * second local, a expanded type (say, a 6-byte structure noted
       * "XXXXXXXXXXX", with 64-bit padding "/"):
       *
       *
       *
       * result->locals
       *       |                ------------
       *       |               |            |
       *       |    -----------|------------v--------------
       *        -->| | | | |===+===|===+===|XXXXXXXXXXX|/|/|
       *           |0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|0|1|2|3|
       *           |===+===| | | | |===+===| | | | | | | | |
       *            ---|------------^--|-------------------
       *               |            |  |
       *                ------------    --------------------------> object
       *
       *           |-> _i          |-> _ref         _exp <-|
       *
       *
       *
       * Note: Those "|->" denote the start value and way of
       *       progression of the pointers
       *
       *
       * result->locals is defined as a (void***) but its real "type" depends on
       * which element is accessed (as in the live stack; but in the live stack,
       * only the first indirection is in the stack).
       *
       */

      if (copy->locals != NULL) {
        j = i;

        local_count = local_size = p = o = 0;

        while (local_count < fd->local_count) {
          while (local_format[i++] != '%');
          expanded = ((local_format[i++] == 'E')?1:0);
          id = 0;
          while (local_format[i] != '%') {
            id = (id * 10) + (local_format[i++] - '0');
          }
          i++;
          if (expanded) {
            p++;
            o = se_strucT[id];
            o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
            local_size += o;
          }
          else {
            p+=2;
          }
          local_count++;
        }

        o = p * sizeof(void*) + local_size;
        result->locals = (void***)se_malloc(o);
        _i   = result->locals;
        _exp = (char*)_i + o;
        _ref = (void**)_i + local_count;

        i = j;
        local_count = 0;
        while (local_count < fd->local_count) {
          while (local_format[i++] != '%');
          expanded = ((local_format[i++] == 'E')?1:0);
          id = 0;
          while (local_format[i] != '%') {
            id = (id * 10) + (local_format[i++] - '0');
          }
          i++;
          var = (copy->locals)[local_count];
          if (expanded) {
            o = n = se_strucT[id];
            o = (o + 7) & ~7; /* 64-bit align: should be fine for most systems */
            _exp -= o;
            *(char**)_i = _exp;
            memcpy(_exp, var, n);
          }
          else {
            *_i = _ref;
            *_ref = *var;
            _ref++;
          }
          local_count++;
          _i++;
        }
      }
    }
  }
  return result;
}

void se_delete_dump_stack(se_dump_stack* ds) {
  if (ds != NULL) {
    if (ds->locals != NULL) free(ds->locals);
    free(ds);
  }
}
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/

/*
   This file (SmartEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/
/*
   The `mark_stack_and_registers' C function is called by the Garbage
   Collector (GC) of SmartEiffel. It has to be customized for some systems,
   but also for some C compilers. This file provides some definitions in the
   end and has to be completed for systems which need specific work.

   On some architectures, addresses increase as the stack grows; or,
   conversely, addresses decrease as the stack grows. A C compiler may be
   clever enough to hide some root object inside registers. Unfortunately all
   registers are not always accessible via the C `setjmp' function!

   Thus, in order to be able to use the GC on your architecture/C-compiler,
   you have to provide the correct `mark_stack_and_registers' function.

   What is the `mark_stack_and_registers' function supposed to do?  The
   `mark_stack_and_registers' function is supposed to notify the GC with all
   the possible roots one can find in the C stack and registers by calling the
   `gc_mark' function. A root is an object which must not be collected.  The
   SmartEiffel GC already knows about some root objects like once function
   results or manifest strings. The `mark_stack_and_registers' function has to
   notify the other possible roots. Obviously, one can find in the C stack any
   kind of adresses, but the `gc_mark' function is clever enough to determine
   if the passed pointer is an Eiffel object or not.  When the passed pointer
   reaches some Eiffel object, this object as well as its descendant(s) are
   automatically marked as un-collectable.

   In order to provide the most appropriate `mark_stack_and_registers'
   function, the very first question is to know about the way the C stack is
   managed (addresses of the stack may increase or decrease as the C stack
   grows). The DEFAULT BEHAVIOUR FOR UNKNOWN SYSTEMS is to consider ADDRESSES
   DECREASE AS THE STACK GROWS, as it's the most common case.  The global C
   variable `stack_bottom' is set with some pointer which is supposed to be
   the bottom of the stack (this variable is automatically initialized in the
   C main function).  Note: using the current stack pointer inside
   `mark_stack_and_registers', it is quite obvious to determine if addresses
   increase or not as the C stack grows.  Note2: on some systems, the stack is
   not in contiguous addresses. In such case, `mark_stack_and_registers' has
   to go through all the stack fragments.

   Some roots may be stored only in registers and not in the C stack.  In
   order to reach the registers as well, the first attempt is to use setjmp,
   in the hope that setjmp will save registers in the stack!  Note: this
   technique do not work on processors using windows registers (such as sparc
   processors).

*/


int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom=NULL;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

static void free_and_remove_from_gcmt(mch* c) {
  /* Remove and free the chunk `c' from the
   * gcmt (Garbage Collector Main Table).
   */
  mch**p=(gcmt+gcmt_used-1);
  mch*save=*p;
  mch*save2;
  p--;
  while(save != c) {
    save2 = save;
    save = *p;
    *p = save2;
    p--;
  }
  free(c);
  gcmt_used--;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next, *current;
  unsigned int count = rsocfl_count();
  if ((count > 50) && (count > (rsoc_count >> 1))) { 
    current=rsocfl;
    rsocfl=NULL;
    while (current != NULL) {
      next=current->next;
      if (current->isize == current->header.size) {
	free_and_remove_from_gcmt(((mch*)current)); 
	rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

int gc_memory_used(void) {
  int i;
  int result = 0;
  mch* mch;
  for (i = gcmt_used; i --> 0; ) {
    mch = gcmt[i];
    switch(mch->state_type) {
    case RSO_USED_CHUNK:
    case FSO_USED_CHUNK:
    case FSO_STORE_CHUNK:
      result += mch->size;
      break;
    default:
      break;
    }
  }
  return result;
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

/* return the mch containing p or NULL if p is not 
 * a valid address or was externally allocated 
 */
mch * gc_find_chunk(void * p){
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if((char*)p<(char*)c+c->size)   /* check for upper bound */
      if (!(FREE_CHUNK(c->state_type)))
	return c;
  }
  return NULL;
}

void gc_mark(void*p) {
  mch * c = gc_find_chunk(p);
  if(NULL != c) 
    (c->amfp)(c,p);
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */
  if (fsocfl == NULL) {
    if (fsoc_count >= fsoc_count_ceil) {
      if (fsoc_count_ceil < FSOC_LIMIT) {
	fsoc_count_ceil <<= 1;
      }
      else {
	unsigned int c = fsoc_count + (fsoc_count/3);
	if (fsoc_count_ceil < c)
	  fsoc_count_ceil = c;
      }
    }
  }
  else {
    if (fsoc_count_ceil < fsoc_count) {
      fsoc_count_ceil = fsoc_count;
    }
  }
  /* Compute rsoc_count_ceil: */
  if (rsocfl == NULL) {
    if (rsoc_count >= rsoc_count_ceil) {
      if (rsoc_count_ceil < RSOC_LIMIT) {
	rsoc_count_ceil <<= 1;
      }
      else {
	unsigned int c = rsoc_count + (rsoc_count / 3);
	if (rsoc_count_ceil < c) {
	  rsoc_count_ceil = c;
	}
      }
    }
  }
  else {
    if (rsoc_count_ceil < rsoc_count) {
      rsoc_count_ceil = rsoc_count;
    }
  }
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).
  */
  mch** p;
  if (gcmt_used == gcmt_max) {
    gcmt_max <<= 1;
    gcmt = ((mch**)(se_realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
  }
  for (p=gcmt+(gcmt_used++ -1) ; (p>=gcmt)&&(*p>c) ; p--) {
    *(p+1) = *p;
  }
  *(p+1) = c;
}

static char*rso_from_store(na_env*nae,unsigned int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      pp->header.magic_flag=RSOH_FREE;
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

static const rsoc MRSOC = {
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(unsigned int size) {
  unsigned int best_size = 0;
  rsoc *pc,*best_pc,*best_c, *c;
  if (rsocfl==NULL)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (best_pc != NULL)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  do {
    if ((c->header.size >= size) && (c->header.size < best_size)) {
      best_c = c;
      best_pc = pc;
      best_size = c->header.size;
    }
    pc=c;
    c=c->next;
  }
  while(c!=NULL);
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,unsigned int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,unsigned int size) {
  rsoc*c=nae->chunk_list;
  unsigned int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if ((c->header.size > RSOC_SIZE)
	&&
	(c->header.size-csize > RSOC_MIN_STORE*4)) {
      int csize_left=c->header.size-csize;
      if ((csize_left%sizeof(double))!=0) {
	csize_left-=(csize_left%sizeof(double));
	csize=c->header.size-csize_left;
      }
      c->header.size=csize_left;
      c->next=rsocfl;
      rsocfl=c;
      c=(rsoc*)(((char*)c)+csize_left);
      gc_add_into_gcmt((mch*)c);
      c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
      c->header.swfp=(void(*)(mch*))rsoc_sweep;
    }
    else {
      csize=c->header.size;
    }
    c->header.size=csize;
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    return rso_from_store(nae,size);
  }
  return NULL;
}

char*new_na(na_env*nae,unsigned int size) {
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      unsigned int rounded_size= chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    unsigned int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);

  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

unsigned int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  unsigned int r=0;
  rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

unsigned int fsocfl_count(void) {
  unsigned int r=0;
  fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    fsoc_count++;
    gc_update_ceils();
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

#if defined(__sparc__) || defined(sparc) || defined(__sparc)
/* For SPARC architecture.
   As this part contains assembly code (asm), you must not use
   the flag -ansi of gcc compiler.
*/

void mark_loop(void) {
  void** max = stack_bottom;
  void** stack_pointer;
  void* stack_top[2]={NULL,NULL};
  stack_pointer = stack_top;
  /* Addresses decrease as the stack grows. */
  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}

void mark_stack_and_registers(void) {
#  if defined(__sparcv9)
  asm(" flushw");
#  else
  asm(" ta      0x3   ! ST_FLUSH_WINDOWS");
#  endif
  mark_loop();
}

#elif defined(__ELATE__) || defined(ELATE)
/* GNU Eiffel's VP (Virtual Processor) garbage collector for Elate.
   (c) 2000 Rudi Chiarito <rudi@amiga.com>

   Thanks to Andy Stout and Kevin Croombs at Tao Group for their
   precious help!

   ChangeLog:
   - 2000-06-12 Rudi Chiarito <rudi@amiga.com>
     * Version 1.0
   - 2001-01-01 Joseph Kiniry <kiniry@acm.org>
     * Integrated with new SE 0.75b
   - 2001-08-10 Rudi Chiarito <rudi@amiga.com>
     * Inlined and optimised range marking
     * Added some more comments
     * Added conditional breakpoint in mark_stack_and_registers
   - 2002-09-21 Rudi Chiarito <rudi@amiga.com>
     * Removed redundant 'ret'
*/

__inline__ void mark_stack_and_registers(void)
{

  void *pointer_to_gc_mark = &gc_mark;

  __asm__ __volatile__
  (
    /*
      WARNING: funky code ahead!
      \t and \n are needed to make the final output easier to read
      while debugging. Hopefully you'll never have to bother with all
      of this.

      Registers:
        p0  pointer to stack block
        p1  pointer to gc_mark()
        p2  scratch pointer
        i0  length of current stack block
        i1  scratch register
    */

#  ifdef __ELATE_SE_DEBUG_GC
   "\tqcall sys/cii/breakpt,(-:-)\n"
#  endif

   "\tsync\n"                          /* spill all the registers */
   "\tsyncreg\n"                       /* to the stack */

   "\tcpy.p %0,p1\n"                   /* pointer to gc_mark() */

   /* pointer to the current stack block */
   "\tcpy.p [gp+PROC_STACK],p0\n"

   /* point to last location in the block, before the descriptor */
   "\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

   /* mark the contents of the current stack block */
   "\twhile p2>=sp\n"
      "\t\tgos p1,(p2 : -)\n"
      "\t\tsub.p 4,p2\n"
   "\tendwhile\n"

   /* now scan other blocks (if any) */

   "\tloop\n"
      "\t\tcpy.p [p0 - STK_SIZE + STK_LINK],p0\n" /* get next block */
      "\t\tbreakif p0=NULL\n"

      /* point to last location in the block, before the descriptor */
      "\t\tcpy.p p0 + ([(p0 - STK_SIZE) + STK_LENGTH] - STK_SIZE - 4),p2\n"

      /* mark this block */
      "\t\twhile p2>=p0\n"

         "\t\t\tgos p1,(p2 : -)\n"
         "\t\t\tsub.p 4,p2\n"
      "\t\tendwhile\n"
   "\tendloop\n"

   : /* no output */
   : "p" (pointer_to_gc_mark)
   : "p0", "p1", "p2", "i0" 
   );
}

#elif defined(__hppa__) || defined(__hppa) || defined(__hp9000) || \
      defined(__hp9000s300) || defined(hp9000s300) || \
      defined(__hp9000s700) || defined(hp9000s700) || \
      defined(__hp9000s800) || defined(hp9000s800) || defined(hp9000s820)

/****************************************************************************
 * Generic code for architectures where addresses increase as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(&registers) + ((sizeof(JMP_BUF)/sizeof(void*))-1);
  /* stack_pointer will traverse the JMP_BUF as well (jmp_buf size is added, 
     otherwise stack_pointer would be below the registers structure). */

#  if !defined(SE_BOOST)
  if (stack_pointer < max) {
    fprintf(stderr, "Wrong stack direction: your stack decrease as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer >= max) {
    gc_mark(*(stack_pointer--));
  }
}
#else

/****************************************************************************
 * Generic code for architectures where addresses decrease as the stack grows.
 ****************************************************************************/

void mark_stack_and_registers(void){
  void** max = stack_bottom;
  JMP_BUF registers;   /* The jmp_buf buffer is in the C stack. */
  void**stack_pointer; /* Used to traverse the stack and registers assuming
			  that `setjmp' will save registers in the C stack.
		       */

  (void)SETJMP(registers);  /* To fill the C stack with registers. */
  stack_pointer = (void**)(&registers);

#  if !defined(SE_BOOST)
  if (stack_pointer > max) {
    fprintf(stderr, "Wrong stack direction: the stack addresses increase as the stack grows (or complex stack management). Please drop an e-mail to SmartEiffel@loria.fr\n");
    exit(1); }
#  endif

  while (stack_pointer <= max) {
    gc_mark(*(stack_pointer++));
  }
}
#endif

/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_io.c) is automatically
  included when some external "SmartEiffel" basic_io_* feature is used.
*/

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
/* macro read is used of basic_io_read_stdin */
#else
int basic_io_read_stdin(char *buffer, int size) {
  int c;
  c = getc(stdin);
  if (c==EOF)
    return 0;
  *buffer = (char)c;
  return 1;
}
#endif

unsigned int fsoc_count_ceil=48;
unsigned int rsoc_count_ceil=8;

/*BOOLEAN*/
T6 r6_ix_and(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix and BOOLEAN",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C02008/*l32c4/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C02714/*l39c10/boolean.e*/);
R=((T6)((T6)((C)&&((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*BOOLEAN*/
T6 r6_px_not(se_dump_stack*caller,T6 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"prefix not BOOLEAN",1,1,"%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C04918/*l73c12/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C04C06/*l76c3/boolean.e*/);
R=((T6)((C)==(0)));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*BOOLEAN*/
T6 r6_ix_or(se_dump_stack*caller,T6 C,T6 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix or BOOLEAN",1,2,"%E6%other%E6%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00C03408/*l52c4/boolean.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00C03B14/*l59c10/boolean.e*/);
R=((T6)((T6)((C)||((T6)(a1)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T6 r3is_default(se_dump_stack*caller,T3 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default GENERAL",1,1,"%E3%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01E10F08/*l271c4/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01E11806/*l280c3/general.e*/);
R=((T6)((C)==(r3default(&ds))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*CHARACTER*/
T3 r3default(se_dump_stack*caller){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"default GENERAL",0,1,"Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x01E10816/*l264c11/general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T6 r2is_equal(se_dump_stack*caller,T2 C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C32A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02C32C06/*l812c3/integer_general.e*/);
R=((T6)((r2to_integer_64(&ds,(/*RF2*/a1)))==(r2to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[2]))==((void*)((T0*)(t[2])))))||((T6)((R)==(r2is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2max(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"max COMPARABLE",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E07308/*l115c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E07620/*l118c16/comparable.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x02E0782A/*l120c21/comparable.e*/),(int32_t)((C)>=(a1)))){
(ds.p=0x02E0791A/*l121c13/comparable.e*/);
R=C;
}
else{
(ds.p=0x02E07B1A/*l123c13/comparable.e*/);
R=a1;
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E07E38/*l126c28/comparable.e*/);
ac_ens((T6)(((int32_t)((R)>=(C)))&&((T6)((int32_t)((R)>=(a1))))),NULL);
(ds.p=0x02E07F3C/*l127c30/comparable.e*/);
ac_ens((T6)(((r2compare(&ds,C,R))==(INT8_C(0)))||((T6)((r2compare(&ds,a1,R))==(INT8_C(0))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T6 r2divisible(se_dump_stack*caller,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"divisible INTEGER_GENERAL",0,2,"other%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=NULL;
ds.p=0x02C32508/*l805c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03004620/*l70c16/numeric.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02C32714/*l807c10/integer_general.e*/);
R=((T6)(((/*RF2*/a1))!=(INT8_C(0))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2compare(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"compare COMPARABLE",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02E05308/*l83c4/comparable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E0573C/*l87c30/comparable.e*/);
ac_req((/*exp-void-cmp*/1),"other_exists");
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x02E0592A/*l89c21/comparable.e*/),(int32_t)((C)<(a1)))){
(ds.p=0x02E05A1A/*l90c13/comparable.e*/);
R=INT8_C(-1);
}
 else if(((ds.p=0x02E05B2E/*l91c23/comparable.e*/),(int32_t)((a1)<(C)))){
(ds.p=0x02E05C1A/*l92c13/comparable.e*/);
R=INT8_C(1);
}
/*FI]*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02E05F54/*l95c42/comparable.e*/);
ac_ens(((R)==(INT8_C(0)))==(r2is_equal(&ds,C,a1)),"equal_zero");
(ds.p=0x02E06054/*l96c42/comparable.e*/);
ac_ens(((R)==(INT8_C(-1)))==((int32_t)((C)<(a1))),"smaller_negative");
(ds.p=0x02E06154/*l97c42/comparable.e*/);
ac_ens(((R)==(INT8_C(1)))==((int32_t)((C)>(a1))),"greater_positive");
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_42(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix * INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C04708/*l71c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C04942/*l73c33/integer_general.e*/);
ac_req((T6)((!(r2divisible(&ds,a1)))||((T6)(((int32_t)(((int32_t)(((/*RF2*/C))*((/*RF2*/a1))))/((/*RF2*/a1))))==((/*RF2*/C))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x02C04B06/*l75c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))*(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C04D42/*l77c33/integer_general.e*/);
ac_ens((T6)((!(r6_ix_and(&ds,(T6)(((/*RF2*/C))!=(INT8_C(0))),(T6)(((/*RF2*/a1))!=(INT8_C(0))))))||((T6)((R)!=(INT8_C(0))))),NULL);
(ds.p=0x02C04E1E/*l78c15/integer_general.e*/);
ac_ens((T6)((!((R)!=(INT8_C(0))))||((T6)(((int32_t)((R)/((/*RF2*/a1))))==((/*RF2*/C))))),NULL);
(ds.p=0x02C04F1E/*l79c15/integer_general.e*/);
ac_ens((T6)((!((R)!=(INT8_C(0))))||((T6)(((int32_t)((R)%((/*RF2*/a1))))==(INT8_C(0))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_43(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix + INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C03108/*l49c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C03358/*l51c44/integer_general.e*/);
ac_req((T6)((!(((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/a1))>(/*IC*/(T2)(INT8_C(0)))))))||((T6)(((int32_t)(((int32_t)((C)+(a1)))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x02C03706/*l55c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))+(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C03930/*l57c24/integer_general.e*/);
ac_ens(((int32_t)((R)-((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T2 r2_ix_45(se_dump_stack*caller,T2 C,T2 a1){
T2 R=0;
void**locals[2];
static se_frame_descriptor fd={"infix - INTEGER_GENERAL",1,2,"%E2%other%E2%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C03C08/*l60c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C03E5A/*l62c45/integer_general.e*/);
ac_req((T6)((!(((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))!=((int32_t)(((/*RF2*/a1))>(/*IC*/(T2)(INT8_C(0)))))))||((T6)(((int32_t)(((int32_t)((C)-(a1)))>(/*IC*/(T2)(INT8_C(0)))))==((int32_t)(((/*RF2*/C))>(/*IC*/(T2)(INT8_C(0)))))))),"no_overflow");
fd.assertion_flag=1;
}
(ds.p=0x02C04206/*l66c3/integer_general.e*/);
R=(int32_t)(((/*RF2*/C))-(a1));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C04430/*l68c24/integer_general.e*/);
ac_ens(((int32_t)((R)+((/*RF2*/a1))))==((/*RF2*/C)),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER*/
T11 r2to_integer_64(se_dump_stack*caller,T2 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E2%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C13708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02C13A06/*l314c3/integer_general.e*/);
R=/*IC*/(T11)(C);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C13C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,/*IC*/(T11)(C),R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T6 r11is_equal(se_dump_stack*caller,T11 C,T11 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal INTEGER_GENERAL",1,2,"%E11%other%E11%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C32A08/*l810c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07720/*l119c16/general.e*/);
ac_req((/*exp-void-cmp*/1),NULL);
fd.assertion_flag=1;
}
(ds.p=0x02C32C06/*l812c3/integer_general.e*/);
R=((T6)((r11to_integer_64(&ds,(/*RF2*/a1)))==(r11to_integer_64(&ds,(/*RF2*/C)))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01E07A64/*l122c50/general.e*/);
ac_ens((T6)((!(((T0*)(t[11]))==((void*)((T0*)(t[11])))))||((T6)((R)==(r11is_equal(&ds,a1,C))))),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*INTEGER_64*/
T11 r11to_integer_64(se_dump_stack*caller,T11 C){
T11 R=0;
void**locals[1];
static se_frame_descriptor fd={"to_integer_64 INTEGER_GENERAL",1,1,"%E11%Result%E11%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02C13708/*l311c4/integer_general.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02C13A06/*l314c3/integer_general.e*/);
R=C;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02C13C16/*l316c11/integer_general.e*/);
ac_ens(r11is_equal(&ds,C,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T9 r9realloc(se_dump_stack*caller,T9 C,T2 a1,T2 a2){
T9 R=NULL;
void**locals[3];
static se_frame_descriptor fd={"realloc NATIVE_ARRAY",1,3,"%E9%old_nb_elts%E2%new_nb_elts%E2%Result%E9%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03804308/*l67c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03804A14/*l74c10/native_array.e*/);
ac_req(r9is_not_null(&ds,C),NULL);
(ds.p=0x03804B2C/*l75c22/native_array.e*/);
ac_req((int32_t)((a1)>(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03804C2C/*l76c22/native_array.e*/);
ac_req((int32_t)((a1)<(a2)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03804E14/*l78c10/native_array.e*/);
R=new9(a2);
(ds.p=0x03804F22/*l79c17/native_array.e*/);
r9copy_from(&ds,R,C,r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03805122/*l81c17/native_array.e*/);
ac_ens(r9is_not_null(&ds,R),NULL);
fd.assertion_flag=1;
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_at(se_dump_stack*caller,T9 C,T2 a1,T9 a2,T2 a3){
T2 _at_idx=0;
T2 _src_idx=0;
void**locals[5];
static se_frame_descriptor fd={"copy_at NATIVE_ARRAY",1,5,"%E9%at%E2%src%E9%src_capacity%E2%at_idx%E2%src_idx%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03812208/*l290c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&a3;
locals[3]=(void**)&_at_idx;
locals[4]=(void**)&_src_idx;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0381271A/*l295c13/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
(ds.p=0x03812740/*l295c32/native_array.e*/);
ac_req((int32_t)((a3)>=(/*IC*/(T2)(INT8_C(0)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x03812C1A/*l300c13/native_array.e*/);
_src_idx=r2_ix_45(&ds,a3,INT8_C(1));
(ds.p=0x03812D1A/*l301c13/native_array.e*/);
_at_idx=r2_ix_43(&ds,a1,_src_idx);
while (!(((ds.p=0x03812F2A/*l303c21/native_array.e*/),(int32_t)((_src_idx)<(INT8_C(0))))))
{
(ds.p=0x0381311A/*l305c13/native_array.e*/);
(C)[_at_idx]=((a2)[_src_idx]);
(ds.p=0x0381321A/*l306c13/native_array.e*/);
_src_idx=r2_ix_45(&ds,_src_idx,INT8_C(1));
(ds.p=0x0381331A/*l307c13/native_array.e*/);
_at_idx=r2_ix_45(&ds,_at_idx,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9is_not_null(se_dump_stack*caller,T9 C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_not_null NATIVE_ARRAY",1,1,"%E9%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03820B08/*l523c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03820D14/*l525c10/native_array.e*/);
R=((T6)((NULL!=((void*)(C)))));
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
T6 r9all_default(se_dump_stack*caller,T9 C,T2 a1){
T6 R=0;
T2 _i=0;
T3 _v=0;
void**locals[4];
static se_frame_descriptor fd={"all_default NATIVE_ARRAY",1,4,"%E9%upper%E2%Result%E6%i%E2%v%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x0381E608/*l486c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_v;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x0381EC20/*l492c16/native_array.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0381F11A/*l497c13/native_array.e*/);
R=((T6)(1));
(ds.p=0x0381F21A/*l498c13/native_array.e*/);
_i=a1;
while (!(((ds.p=0x0381F426/*l500c19/native_array.e*/),(T6)(((int32_t)((_i)<(INT8_C(0))))||((T6)(r6_px_not(&ds,(T6)(R))))))))
{
(ds.p=0x0381F60C/*l502c6/native_array.e*/);
_v=(C)[_i];
(ds.p=0x0381F812/*l504c9/native_array.e*/);
R=((T6)((_v)==(((T3)'\000'))));
(ds.p=0x0381FA1A/*l506c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_from(se_dump_stack*caller,T9 C,T9 a1,T2 a2){
T2 _i=0;
void**locals[3];
static se_frame_descriptor fd={"copy_from NATIVE_ARRAY",1,3,"%E9%model%E9%upper%E2%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03817F08/*l383c4/native_array.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
locals[2]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x03818212/*l386c9/native_array.e*/);
ac_req((int32_t)((a2)>=(/*IC*/(T2)(INT8_C(-1)))),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0381861E/*l390c15/native_array.e*/);
_i=a2;
while (!(((ds.p=0x03818644/*l390c34/native_array.e*/),(int32_t)((_i)<(INT8_C(0))))))
{
(ds.p=0x0381881A/*l392c13/native_array.e*/);
(C)[_i]=((a1)[_i]);
(ds.p=0x0381891A/*l393c13/native_array.e*/);
_i=r2_ix_45(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T3 r7item(se_dump_stack*caller,T7* C,T2 a1){
T3 R=0;
void**locals[2];
static se_frame_descriptor fd={"item STRING",1,2,"%R7%i%E2%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E07508/*l117c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0782E/*l120c23/string.e*/);
ac_req(r7valid_index(&ds,C,a1),"valid_index");
fd.assertion_flag=1;
}
(ds.p=0x00E07A14/*l122c10/string.e*/);
R=((/*RF2*/(C)->_storage/*1*/))[r2_ix_45(&ds,a1,INT8_C(1))];
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index STRING",1,2,"%R7%i%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E07D08/*l125c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E08014/*l128c10/string.e*/);
R=((T6)((T6)(((int32_t)((INT8_C(1))<=(a1)))&&((T6)((int32_t)((a1)<=((/*RF2*/(C)->_count/*9*/))))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0823A/*l130c29/string.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)((int32_t)((/*IC*/(T2)(INT8_C(1)))<=(a1))),(T6)((int32_t)((a1)<=((/*RF2*/(C)->_count/*9*/)))))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*STRING*/
void r7append(se_dump_stack*caller,T7* C,T0* a1){
T2 _s_count=0;
T2 _needed_capacity=0;
T2 _new_capacity=0;
void**locals[4];
static se_frame_descriptor fd={"append STRING",1,4,"%R7%s%R7%s_count%E2%needed_capacity%E2%new_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E3E708/*l999c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_s_count;
locals[2]=(void**)&_needed_capacity;
locals[3]=(void**)&_new_capacity;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E3EA30/*l1002c24/string.e*/);
ac_req((a1)!=((void*)(NULL)),"s_not_void");
fd.assertion_flag=1;
}
(ds.p=0x00E3EE06/*l1006c3/string.e*/);
_s_count=(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E3EE1C/*l1006c14/string.e*/))))->_count/*9*/);
(ds.p=0x00E3EF14/*l1007c10/string.e*/);
_needed_capacity=r2_ix_43(&ds,(/*RF2*/(C)->_count/*9*/),_s_count);
/*[IF*/
if(((ds.p=0x00E3F03A/*l1008c29/string.e*/),(int32_t)((_needed_capacity)>((/*RF2*/(C)->_capacity/*13*/))))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*13*/))==(INT8_C(0))){
(ds.p=0x00E3F220/*l1010c16/string.e*/);
/*SFN*/(C->_storage/*1*/)=new9(_needed_capacity);
(ds.p=0x00E3F320/*l1011c16/string.e*/);
/*SFN*/(C->_capacity/*13*/)=_needed_capacity;
}
else{
(ds.p=0x00E3F520/*l1013c16/string.e*/);
_new_capacity=r2max(&ds,r2_ix_42(&ds,INT8_C(2),(/*RF2*/(C)->_capacity/*13*/)),_needed_capacity);
(ds.p=0x00E3F612/*l1014c9/string.e*/);
/*SFN*/(C->_storage/*1*/)=r9realloc(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_capacity/*13*/),_new_capacity);
(ds.p=0x00E3F712/*l1015c9/string.e*/);
/*SFN*/(C->_capacity/*13*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x00E3FA24/*l1018c18/string.e*/);
r9copy_at(&ds,(/*RF2*/(C)->_storage/*1*/),(/*RF2*/(C)->_count/*9*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E3FA40/*l1018c32/string.e*/))))->_storage/*1*/),_s_count);
(ds.p=0x00E3FB14/*l1019c10/string.e*/);
/*SFN*/(C->_count/*9*/)=_needed_capacity;
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
void r7make(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"make STRING",1,1,"%R7%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E04208/*l66c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0465C/*l70c46/string.e*/);
ac_req((int32_t)((a1)>=(/*IC*/(T2)(INT8_C(0)))),"non_negative_size");
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x00E0483A/*l72c29/string.e*/),(int32_t)((a1)>(INT8_C(0))))){
/*[IF*/
if(((ds.p=0x00E04932/*l73c25/string.e*/),(int32_t)(((/*RF2*/(C)->_capacity/*13*/))<(a1)))){
(ds.p=0x00E04A20/*l74c16/string.e*/);
/*SFN*/(C->_storage/*1*/)=new9(a1);
(ds.p=0x00E04B20/*l75c16/string.e*/);
/*SFN*/(C->_capacity/*13*/)=a1;
}
/*FI]*/
}
/*FI]*/
(ds.p=0x00E04E14/*l78c10/string.e*/);
/*SFN*/(C->_count/*9*/)=INT8_C(0);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E05034/*l80c26/string.e*/);
ac_ens((int32_t)((a1)<=((/*RF2*/(C)->_capacity/*13*/))),NULL);
(ds.p=0x00E0513C/*l81c30/string.e*/);
ac_ens(((/*RF2*/(C)->_count/*9*/))==(INT8_C(0)),"empty_string");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STRING*/
T0* r7_ix_43(se_dump_stack*caller,T7* C,T0* a1){
T0* R=NULL;
void**locals[2];
static se_frame_descriptor fd={"infix + STRING",1,2,"%R7%other%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x00E43F08/*l1087c4/string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4433C/*l1091c30/string.e*/);
ac_req((a1)!=((void*)(NULL)),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00E44514/*l1093c10/string.e*/);
{T7*n=new7();
r7make(&ds,n,r2_ix_43(&ds,(/*RF2*/(C)->_count/*9*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E44540/*l1093c32/string.e*/))))->_count/*9*/)));
R=((T0*)n);
se_i7(&ds,n);}
(ds.p=0x00E44622/*l1094c17/string.e*/);
r7append(&ds,se_i7(&ds,((T7*)ci(7,R,0x00E44614/*l1094c10/string.e*/))),(T0*)C);
(ds.p=0x00E44722/*l1095c17/string.e*/);
r7append(&ds,se_i7(&ds,((T7*)ci(7,R,0x00E44714/*l1095c10/string.e*/))),a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4494A/*l1097c37/string.e*/);
ac_ens(((/*RF2*/(se_i7(&ds,((T7*)ci(7,R,0x00E44930/*l1097c24/string.e*/))))->_count/*9*/))==(r2_ix_43(&ds,(/*RF2*/(C)->_count/*9*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E4495E/*l1097c47/string.e*/))))->_count/*9*/))),"result_count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}
se_frame_descriptor se_ifd7={"invariant STRING",1,0,"%R7%",1};

T7*se_i7(se_dump_stack*caller,T7*C){
se_dump_stack ds;
ds.fd=&se_ifd7;
ds.current=((void**)&C);
ds.p=0x00E0130E/*l19c7/string.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x00E7560C/*l1878c6/string.e*/);
ac_inv((int32_t)((/*IC*/(T2)(INT8_C(0)))<=((/*RF2*/(C)->_count/*9*/))),NULL);
(ds.p=0x00E75814/*l1880c10/string.e*/);
ac_inv((int32_t)(((/*RF2*/(C)->_count/*9*/))<=((/*RF2*/(C)->_capacity/*13*/))),NULL);
(ds.p=0x00E75A22/*l1882c17/string.e*/);
ac_inv((T6)((!((int32_t)(((/*RF2*/(C)->_capacity/*13*/))>(/*IC*/(T2)(INT8_C(0))))))||((T6)(r9is_not_null(&ds,(/*RF2*/(C)->_storage/*1*/))))),NULL);
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}

/*STD_INPUT_OUTPUT*/
void r18make(se_dump_stack*caller,T18* C){
static se_frame_descriptor fd={"make STD_INPUT_OUTPUT",1,0,"%R18%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02402108/*l33c4/std_input_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC15std_output=NULL;

/*STD_INPUT_OUTPUT*/
void r18put_character(se_dump_stack*caller,T18* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character STD_INPUT_OUTPUT",1,1,"%R18%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02403908/*l57c4/std_input_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02602314/*l35c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
(ds.p=0x02403B1C/*l59c14/std_input_output.e*/);
r27put_character(&ds,((T27*)ci(27,oBC15std_output,0x02403B06/*l59c3/std_input_output.e*/)),a1);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_INPUT_OUTPUT*/
void r18put_string(se_dump_stack*caller,T18* C,T0* a1){
T2 _i=0;
T2 _count=0;
void**locals[3];
static se_frame_descriptor fd={"put_string OUTPUT_STREAM",1,3,"%R18%s%R7%i%E2%count%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02602908/*l41c4/output_stream.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_i;
locals[2]=(void**)&_count;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02602C14/*l44c10/output_stream.e*/);
ac_req(1,NULL);
(ds.p=0x02602D18/*l45c12/output_stream.e*/);
ac_req((a1)!=((void*)(NULL)),NULL);
fd.assertion_flag=1;
}
(ds.p=0x0260321A/*l50c13/output_stream.e*/);
_i=INT8_C(1);
(ds.p=0x0260330C/*l51c6/output_stream.e*/);
_count=(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x0260331E/*l51c15/output_stream.e*/))))->_count/*9*/);
while (!(((ds.p=0x0260351E/*l53c15/output_stream.e*/),(int32_t)((_i)>(_count)))))
{
(ds.p=0x0260371A/*l55c13/output_stream.e*/);
r18put_character(&ds,C,r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x02603736/*l55c27/output_stream.e*/))),_i));
(ds.p=0x0260381A/*l56c13/output_stream.e*/);
_i=r2_ix_43(&ds,_i,INT8_C(1));
}
set_dump_stack_top(caller);/*unlink*/
}
T0*oBC15io=NULL;

/*DOCTOR*/
void r16make(se_dump_stack*caller,T16* C){
static se_frame_descriptor fd={"make DOCTOR",1,0,"%R16%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02000706/*l7c3/doctor.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
}

/*DOCTOR*/
void r16read_health_info(se_dump_stack*caller,T16* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"read_health_info DOCTOR",1,1,"%R16%u%R17%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02000906/*l9c3/doctor.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02000C14/*l12c10/doctor.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x02000C0E/*l12c7/doctor.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,r30health_info(&ds,((T30*)ci(30,a1,0x02000C2A/*l12c21/doctor.e*/))),0x02000C2E/*l12c23/doctor.e*/))),se_ms(1,s16_10)));
set_dump_stack_top(caller);/*unlink*/
}

/*BANK*/
void r33make(se_dump_stack*caller,T33* C){
static se_frame_descriptor fd={"make BANK",1,0,"%R33%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04200706/*l7c3/bank.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
set_dump_stack_top(caller);/*unlink*/
}

/*BANK*/
void r33read_bank_acct(se_dump_stack*caller,T33* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"read_bank_acct BANK",1,1,"%R33%u%R17%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04200906/*l9c3/bank.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04200B14/*l11c10/bank.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x04200B0E/*l11c7/bank.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,r30bank_acct(&ds,((T30*)ci(30,a1,0x04200B2A/*l11c21/bank.e*/))),0x04200B2E/*l11c23/bank.e*/))),se_ms(1,s16_10)));
set_dump_stack_top(caller);/*unlink*/
}

/*VISITOR*/
void r30_17Puk_make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"Precursor uk_make (make PERSON)",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02200A08/*l10c4/person.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02200C10/*l12c8/person.e*/);
/*SFN*/(C->_name/*1*/)=se_ms(29,"A person have only *one* name");
(ds.p=0x02200D10/*l13c8/person.e*/);
/*SFN*/(C->_addr/*9*/)=se_ms(30,"A person can have *multi* addr");
set_dump_stack_top(caller);/*unlink*/
}

/*VISITOR*/
void r30us_make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"us_make (make US_RESIDENT)",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03E00908/*l9c4/us_resident.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
r30_17Pus_make(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*VISITOR*/
void r30make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"make VISITOR",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03C01408/*l20c4/visitor.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03C01610/*l22c8/visitor.e*/);
r30uk_make(&ds,C);
(ds.p=0x03C01710/*l23c8/visitor.e*/);
r30us_make(&ds,C);
(ds.p=0x03C01810/*l24c8/visitor.e*/);
/*SFN*/(C->_addr/*9*/)=se_ms(17,"My hotel in Paris");
(ds.p=0x03C01910/*l25c8/visitor.e*/);
/*SFN*/(C->_uk_addr/*25*/)=se_ms(6,"London");
(ds.p=0x03C01A10/*l26c8/visitor.e*/);
/*SFN*/(C->_us_addr/*17*/)=se_ms(7,"NewYork");
set_dump_stack_top(caller);/*unlink*/
}

/*VISITOR*/
void r30_17Pus_make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"Precursor us_make (make PERSON)",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02200A08/*l10c4/person.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02200C10/*l12c8/person.e*/);
/*SFN*/(C->_name/*1*/)=se_ms(29,"A person have only *one* name");
(ds.p=0x02200D10/*l13c8/person.e*/);
/*SFN*/(C->_addr/*9*/)=se_ms(30,"A person can have *multi* addr");
set_dump_stack_top(caller);/*unlink*/
}

/*VISITOR*/
T0* r30health_info(se_dump_stack*caller,T30* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"health_info PERSON",1,1,"%R30%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02201508/*l21c4/person.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x0220153C/*l21c30/person.e*/);
R=se_ms(37,"health_info: only view-able by doctor");
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*VISITOR*/
T0* r30bank_acct(se_dump_stack*caller,T30* C){
T0* R=NULL;
void**locals[1];
static se_frame_descriptor fd={"bank_acct PERSON",1,1,"%R30%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x02201208/*l18c4/person.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x02201238/*l18c28/person.e*/);
R=se_ms(33,"bank_acct: only view-able by bank");
set_dump_stack_top(caller);/*unlink*/
return R;
}

/*VISITOR*/
void r30uk_make(se_dump_stack*caller,T30* C){
static se_frame_descriptor fd={"uk_make (make UK_RESIDENT)",1,0,"%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x04000A08/*l10c4/uk_resident.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
r30_17Puk_make(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r27make(se_dump_stack*caller,T27* C){
static se_frame_descriptor fd={"make STD_OUTPUT",1,0,"%R27%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03602808/*l40c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x03602A14/*l42c10/std_output.e*/);
/*SFN*/(C->_buffer/*5*/)=new9(INT16_C(4096));
(ds.p=0x03602B14/*l43c10/std_output.e*/);
/*SFN*/(C->_capacity/*13*/)=INT16_C(4096);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r27flush(se_dump_stack*caller,T27* C){
static se_frame_descriptor fd={"flush STD_OUTPUT",1,0,"%R27%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03603C08/*l60c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x03603E2C/*l62c22/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>(INT8_C(0))))){
(ds.p=0x03603F0C/*l63c6/std_output.e*/);
r27write_buffer(&ds,C);
}
/*FI]*/
(ds.p=0x03604106/*l65c3/std_output.e*/);
basic_io_flush(basic_io_stdout);
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r27write_buffer(se_dump_stack*caller,T27* C){
static se_frame_descriptor fd={"write_buffer STD_OUTPUT",1,0,"%R27%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03604C08/*l76c4/std_output.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
/*[IF*/
if(((ds.p=0x03604E2C/*l78c22/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>(INT8_C(0))))){
(ds.p=0x03604F0C/*l79c6/std_output.e*/);
basic_io_fwrite((/*RF2*/(C)->_buffer/*5*/),(/*RF2*/(C)->_buffer_position/*1*/),basic_io_stdout);
(ds.p=0x0360500C/*l80c6/std_output.e*/);
/*SFN*/(C->_buffer_position/*1*/)=INT8_C(0);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*STD_OUTPUT*/
void r27put_character(se_dump_stack*caller,T27* C,T3 a1){
void**locals[1];
static se_frame_descriptor fd={"put_character STD_OUTPUT",1,1,"%R27%c%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x03603008/*l48c4/std_output.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
se_require_uppermost_flag=1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x02602314/*l35c10/output_stream.e*/);
ac_req(1,NULL);
fd.assertion_flag=1;
}
/*[IF*/
if(((ds.p=0x0360323A/*l50c29/std_output.e*/),(int32_t)(((/*RF2*/(C)->_buffer_position/*1*/))>=(INT16_C(4096))))){
(ds.p=0x0360331A/*l51c13/std_output.e*/);
r27write_buffer(&ds,C);
}
/*FI]*/
(ds.p=0x03603514/*l53c10/std_output.e*/);
((/*RF2*/(C)->_buffer/*5*/))[(/*RF2*/(C)->_buffer_position/*1*/)]=(a1);
(ds.p=0x03603614/*l54c10/std_output.e*/);
/*SFN*/(C->_buffer_position/*1*/)=r2_ix_43(&ds,(/*RF2*/(C)->_buffer_position/*1*/),INT8_C(1));
/*[IF*/
if((a1)==(((T3)'\n'))){
(ds.p=0x0360380C/*l56c6/std_output.e*/);
r27write_buffer(&ds,C);
}
/*FI]*/
set_dump_stack_top(caller);/*unlink*/
}

/*APP*/
void r12print_us_addr(se_dump_stack*caller,T12* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"print_us_addr APP",1,1,"%R12%u%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01800D08/*l13c4/app.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01800D4E/*l13c39/app.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x01800D48/*l13c36/app.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,r7_ix_43(&ds,((T7*)se_ms(9,"UK addr: ")),(/*RF2*/(((T30*)ci(30,a1,0x01800D80/*l13c64/app.e*/)))->_us_addr/*17*/)),0x01800D7C/*l13c62/app.e*/))),se_ms(1,s16_10)));
set_dump_stack_top(caller);/*unlink*/
}

/*APP*/
void r12main(se_dump_stack*caller,T12* C){
static se_frame_descriptor fd={"main APP",1,0,"%R12%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01800F08/*l15c4/app.e*/;
ds.caller=caller;
ds.locals=NULL;
ds.exception_origin=NULL;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01801106/*l17c3/app.e*/);
{T33*n=new33();
r33make(&ds,n);
/*SFN*/(C->_bank/*9*/)=((T0*)n);
}
(ds.p=0x01801206/*l18c3/app.e*/);
{T16*n=new16();
r16make(&ds,n);
/*SFN*/(C->_doctor/*17*/)=((T0*)n);
}
(ds.p=0x01801306/*l19c3/app.e*/);
{T30*n=new30();
r30make(&ds,n);
/*SFN*/(C->_visitor/*1*/)=((T0*)n);
}
(ds.p=0x0180151A/*l21c13/app.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x01801514/*l21c10/app.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(((T30*)ci(30,(/*RF2*/(C)->_visitor/*1*/),0x01801530/*l21c24/app.e*/)))->_name/*1*/),0x01801540/*l21c32/app.e*/))),se_ms(1,s16_10)));
(ds.p=0x0180161A/*l22c13/app.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x01801614/*l22c10/app.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,(/*RF2*/(((T30*)ci(30,(/*RF2*/(C)->_visitor/*1*/),0x01801630/*l22c24/app.e*/)))->_addr/*9*/),0x01801640/*l22c32/app.e*/))),se_ms(1,s16_10)));
(ds.p=0x01801706/*l23c3/app.e*/);
r12print_uk_addr(&ds,C,(/*RF2*/(C)->_visitor/*1*/));
(ds.p=0x01801806/*l24c3/app.e*/);
r12print_us_addr(&ds,C,(/*RF2*/(C)->_visitor/*1*/));
(ds.p=0x01801A10/*l26c8/app.e*/);
r33read_bank_acct(&ds,((T33*)ci(33,(/*RF2*/(C)->_bank/*9*/),0x01801A06/*l26c3/app.e*/)),(/*RF2*/(C)->_visitor/*1*/));
(ds.p=0x01801B14/*l27c10/app.e*/);
r16read_health_info(&ds,((T16*)ci(16,(/*RF2*/(C)->_doctor/*17*/),0x01801B06/*l27c3/app.e*/)),(/*RF2*/(C)->_visitor/*1*/));
set_dump_stack_top(caller);/*unlink*/
}

/*APP*/
void r12print_uk_addr(se_dump_stack*caller,T12* C,T0* a1){
void**locals[1];
static se_frame_descriptor fd={"print_uk_addr APP",1,1,"%R12%u%R30%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void**)&C;
ds.p=0x01800C08/*l12c4/app.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01800C4E/*l12c39/app.e*/);
r18put_string(&ds,((T18*)ci(18,oBC15io,0x01800C48/*l12c36/app.e*/)),r7_ix_43(&ds,se_i7(&ds,((T7*)ci(7,r7_ix_43(&ds,((T7*)se_ms(9,"US addr: ")),(/*RF2*/(((T30*)ci(30,a1,0x01800C80/*l12c64/app.e*/)))->_uk_addr/*25*/)),0x01800C7C/*l12c62/app.e*/))),se_ms(1,s16_10)));
set_dump_stack_top(caller);/*unlink*/
}
T12*eiffel_root_object=NULL;
int se_argc;
char**se_argv;
T7*g[34];
T7*t[34];
char*p[34];
void(*se_prinT[34])(FILE*,void**);
int se_strucT[34];

void se_atexit(void){
se_frame_descriptor fd={"<atexit wrapper>",0,0,"",1};
se_dump_stack ds;
ds.fd=&fd;
ds.p=0;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
{
T0*C=oBC15std_output;
r27flush(&ds,((T27*)C));
}
}

void initialize_eiffel_runtime(int argc,char*argv[]){
se_frame_descriptor irfd={"<runtime init>",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&irfd;
set_dump_stack_top(&ds);/*link*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));
if (!stack_bottom) stack_bottom=((void**)(&argc));
p[0]="???";
p[29]="/Users/zhou/project/SmartEiffel/lib/kernel/safe_equal.e";
p[19]="/Users/zhou/project/SmartEiffel/lib/io/output_stream.e";
p[14]="/Users/zhou/project/SmartEiffel/lib/kernel/platform.e";
p[22]="/Users/zhou/project/SmartEiffel/lib/kernel/integer_general.e";
p[31]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/us_resident.e";
p[2]="/Users/zhou/project/SmartEiffel/lib/kernel/integer.e";
p[7]="/Users/zhou/project/SmartEiffel/lib/kernel/string.e";
p[23]="/Users/zhou/project/SmartEiffel/lib/kernel/comparable.e";
p[17]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/person.e";
p[13]="/Users/zhou/project/SmartEiffel/lib/kernel/any.e";
p[12]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/app.e";
p[27]="/Users/zhou/project/SmartEiffel/lib/io/std_output.e";
p[24]="/Users/zhou/project/SmartEiffel/lib/kernel/numeric.e";
p[15]="/Users/zhou/project/SmartEiffel/lib/kernel/general.e";
p[26]="TUPLE";
p[11]="/Users/zhou/project/SmartEiffel/lib/kernel/integer_64.e";
p[25]="/Users/zhou/project/SmartEiffel/lib/kernel/hashable.e";
p[8]="/Users/zhou/project/SmartEiffel/lib/kernel/pointer.e";
p[33]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/bank.e";
p[28]="/Users/zhou/project/SmartEiffel/lib/kernel/native_array.e";
p[16]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/doctor.e";
p[32]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/uk_resident.e";
p[3]="/Users/zhou/project/SmartEiffel/lib/kernel/character.e";
p[21]="/Users/zhou/project/SmartEiffel/lib/kernel/string_handler.e";
p[20]="/Users/zhou/project/SmartEiffel/lib/io/input_stream.e";
p[6]="/Users/zhou/project/SmartEiffel/lib/kernel/boolean.e";
p[30]="/Users/zhou/project/contrib/dlang_tour/eiffel/visitor2/visitor.e";
p[18]="/Users/zhou/project/SmartEiffel/lib/io/std_input_output.e";
se_prinT[18]=((void(*)(FILE*,void**))se_prinT18);
se_strucT[18]=sizeof(T18);
se_prinT[8]=((void(*)(FILE*,void**))se_prinT8);
se_strucT[8]=sizeof(T8);
se_prinT[6]=((void(*)(FILE*,void**))se_prinT6);
se_strucT[6]=sizeof(T6);
se_prinT[3]=((void(*)(FILE*,void**))se_prinT3);
se_strucT[3]=sizeof(T3);
se_prinT[12]=((void(*)(FILE*,void**))se_prinT12);
se_strucT[12]=sizeof(T12);
se_prinT[16]=((void(*)(FILE*,void**))se_prinT16);
se_strucT[16]=sizeof(T16);
se_prinT[7]=((void(*)(FILE*,void**))se_prinT7);
se_strucT[7]=sizeof(T7);
se_prinT[33]=((void(*)(FILE*,void**))se_prinT33);
se_strucT[33]=sizeof(T33);
se_prinT[9]=((void(*)(FILE*,void**))se_prinT9);
p[9]=p[28];
se_strucT[9]=sizeof(T9);
se_prinT[2]=((void(*)(FILE*,void**))se_prinT2);
se_strucT[2]=sizeof(T2);
se_prinT[30]=((void(*)(FILE*,void**))se_prinT30);
se_strucT[30]=sizeof(T30);
se_prinT[11]=((void(*)(FILE*,void**))se_prinT11);
se_strucT[11]=sizeof(T11);
se_prinT[27]=((void(*)(FILE*,void**))se_prinT27);
se_strucT[27]=sizeof(T27);
g[29]=(T7*)se_string("SAFE_EQUAL");
g[19]=(T7*)se_string("OUTPUT_STREAM");
g[14]=(T7*)se_string("PLATFORM");
g[22]=(T7*)se_string("INTEGER_GENERAL");
g[31]=(T7*)se_string("US_RESIDENT");
g[2]=(T7*)se_string("INTEGER");
g[7]=(T7*)se_string("STRING");
g[23]=(T7*)se_string("COMPARABLE");
g[17]=(T7*)se_string("PERSON");
g[13]=(T7*)se_string("ANY");
g[12]=(T7*)se_string("APP");
g[27]=(T7*)se_string("STD_OUTPUT");
g[24]=(T7*)se_string("NUMERIC");
g[15]=(T7*)se_string("GENERAL");
g[26]=(T7*)se_string("TUPLE");
g[11]=(T7*)se_string("INTEGER_64");
g[25]=(T7*)se_string("HASHABLE");
g[8]=(T7*)se_string("POINTER");
g[33]=(T7*)se_string("BANK");
g[28]=(T7*)se_string("NATIVE_ARRAY");
g[16]=(T7*)se_string("DOCTOR");
g[32]=(T7*)se_string("UK_RESIDENT");
g[3]=(T7*)se_string("CHARACTER");
g[21]=(T7*)se_string("STRING_HANDLER");
g[20]=(T7*)se_string("INPUT_STREAM");
g[6]=(T7*)se_string("BOOLEAN");
g[0]=(T7*)se_string("NONE");
g[30]=(T7*)se_string("VISITOR");
g[18]=(T7*)se_string("STD_INPUT_OUTPUT");
g[9]=g[28];
t[18]=g[18];
t[8]=g[8];
t[6]=g[6];
t[3]=g[3];
t[12]=g[12];
t[16]=g[16];
t[7]=g[7];
t[33]=g[33];
t[9]=(T7*)se_string("NATIVE_ARRAY[CHARACTER]");
t[2]=g[2];
t[30]=g[30];
t[11]=g[11];
t[27]=g[27];
#ifdef SIGINT
signal(SIGINT,se_signal_handler);
#endif
#ifdef SIGTERM
signal(SIGTERM,se_signal_handler);
#endif
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
/*PCO*/
(ds.p=0x01E13414/*l308c10/general.e*/);
{T18*n=new18();
oBC15io=((T0*)n);
r18make(&ds,n);
}
/*PCO*/
(ds.p=0x01E14214/*l322c10/general.e*/);
{T27*n=new27();
oBC15std_output=((T0*)n);
r27make(&ds,n);
}
/*PCO*/
gc_is_off=0;
{
T12*n=new12();
eiffel_root_object=n;
}
set_dump_stack_top(NULL);/*unlink*/
}
int main(int argc,char*argv[]){
stack_bottom=((void**)(&argc));
initialize_eiffel_runtime(argc,argv);
{T12*n=eiffel_root_object;
se_frame_descriptor root={"<system root>",1,0,"%R12%",1};
se_dump_stack ds;
ds.fd=&root;
ds.current=((void**)(&n));
ds.p=0x01800F08/*l15c4/app.e*/;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r12main(&ds,n);
set_dump_stack_top(NULL);/*unlink*/
}
exit(0);
return 0;}

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}

void manifest_string_mark1(void){
}

void once_function_mark(void){
if(NULL!=oBC15io)gc_mark18((T18*)(oBC15io));
if(NULL!=oBC15std_output)gc_mark27((T27*)(oBC15std_output));
}

void gc_start(void){
if(gc_is_off)return;
if(garbage_delayed())return;
gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);
((gc12*)eiffel_root_object)->header.flag=FSOH_UNMARKED;
gc_free18=NULL;
gc_free12=NULL;
gc_free16=NULL;
gc_free7=NULL;
gc_free33=NULL;
if(na_env9.store_left>0){
na_env9.store->header.size=na_env9.store_left;
na_env9.store->header.magic_flag=RSOH_FREE;
na_env9.store_left=0;
}
na_env9.chunk_list=NULL;
na_env9.store_chunk=NULL;
gc_free30=NULL;
gc_free27=NULL;
gc_mark12(eiffel_root_object);
manifest_string_mark1();
once_function_mark();
{int i=SE_MAXID-1;
while(i>=0){
if(g[i]!=NULL)gc_mark7(g[i]);
i--;}
}
{int i=SE_MAXID-1;
while(i>=0){
if(t[i]!=NULL)gc_mark7(t[i]);
i--;}
}
mark_stack_and_registers();
gc_sweep();
collector_counter++;
}
gc18*store18=NULL;
int store_left18=0;
fsoc*store_chunk18=NULL;
gc18*gc_free18=NULL;
gc12*store12=NULL;
int store_left12=0;
fsoc*store_chunk12=NULL;
gc12*gc_free12=NULL;
gc16*store16=NULL;
int store_left16=0;
fsoc*store_chunk16=NULL;
gc16*gc_free16=NULL;
gc7*store7=NULL;
int store_left7=0;
fsoc*store_chunk7=NULL;
gc7*gc_free7=NULL;
gc33*store33=NULL;
int store_left33=0;
fsoc*store_chunk33=NULL;
gc33*gc_free33=NULL;
na_env na_env9={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark9};
gc30*store30=NULL;
int store_left30=0;
fsoc*store_chunk30=NULL;
gc30*gc_free30=NULL;
gc27*store27=NULL;
int store_left27=0;
fsoc*store_chunk27=NULL;
gc27*gc_free27=NULL;

void gc_sweep18(fsoc*c){
gc18*o1,*o2,*flt,flh;
o1=((gc18*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store18;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free18;
gc_free18=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free18;
gc_free18=flh.header.next;
}
}
}

void gc_mark18(T18*o){
se_gc_check_id(o,18);
{((gc18*)o)->header.flag=FSOH_MARKED;

}}

void gc_align_mark18(fsoc*c,gc18*p){
gc18*b=((gc18*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store18)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T18*o=(&(p->object));
((gc18*)o)->header.flag=FSOH_MARKED;
}
}
}
fsoc H18={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark18,
(void(*)(mch*))gc_sweep18},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc18))-1)};

T18*new18(void){
gc18*n;
fsoc*c;
if(store_left18>1){
store_left18--;
n=store18++;
}
else if(gc_free18!=NULL){
n=gc_free18;
gc_free18=n->header.next;
}
else if(store_left18==1){
store_left18=0;
store_chunk18->header.state_type=FSO_USED_CHUNK;
n=store18++;
}
else{
c=gc_fsoc_get1();
if(gc_free18!=NULL){
n=gc_free18;
gc_free18=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk18=c;
*store_chunk18=H18;
store18=((gc18*)(&(store_chunk18->first_object)));
store_left18=H18.count_minus_one;
n=store18++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M18;
return((T18*)n);
}

void gc_sweep12(fsoc*c){
gc12*o1,*o2,*flt,flh;
o1=((gc12*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store12;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free12;
gc_free12=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free12;
gc_free12=flh.header.next;
}
}
}

void gc_mark12(T12*o){
se_gc_check_id(o,12);
{if(((gc12*)o)->header.flag==FSOH_UNMARKED){
((gc12*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_doctor/*17*/)gc_mark16((T16*)(o->_doctor/*17*/));
if(NULL!=o->_bank/*9*/)gc_mark33((T33*)(o->_bank/*9*/));
if(NULL!=o->_visitor/*1*/)gc_mark30((T30*)(o->_visitor/*1*/));
}
}}

void gc_align_mark12(fsoc*c,gc12*p){
gc12*b=((gc12*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store12)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T12*o=(&(p->object));
((gc12*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_doctor/*17*/)gc_mark16((T16*)(o->_doctor/*17*/));
if(NULL!=o->_bank/*9*/)gc_mark33((T33*)(o->_bank/*9*/));
if(NULL!=o->_visitor/*1*/)gc_mark30((T30*)(o->_visitor/*1*/));
}
}
}
fsoc H12={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark12,
(void(*)(mch*))gc_sweep12},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc12))-1)};

T12*new12(void){
gc12*n;
fsoc*c;
if(store_left12>1){
store_left12--;
n=store12++;
}
else if(gc_free12!=NULL){
n=gc_free12;
gc_free12=n->header.next;
}
else if(store_left12==1){
store_left12=0;
store_chunk12->header.state_type=FSO_USED_CHUNK;
n=store12++;
}
else{
c=gc_fsoc_get1();
if(gc_free12!=NULL){
n=gc_free12;
gc_free12=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk12=c;
*store_chunk12=H12;
store12=((gc12*)(&(store_chunk12->first_object)));
store_left12=H12.count_minus_one;
n=store12++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M12;
return((T12*)n);
}

void gc_sweep16(fsoc*c){
gc16*o1,*o2,*flt,flh;
o1=((gc16*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store16;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free16;
gc_free16=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free16;
gc_free16=flh.header.next;
}
}
}

void gc_mark16(T16*o){
se_gc_check_id(o,16);
{((gc16*)o)->header.flag=FSOH_MARKED;

}}

void gc_align_mark16(fsoc*c,gc16*p){
gc16*b=((gc16*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store16)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T16*o=(&(p->object));
((gc16*)o)->header.flag=FSOH_MARKED;
}
}
}
fsoc H16={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark16,
(void(*)(mch*))gc_sweep16},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc16))-1)};

T16*new16(void){
gc16*n;
fsoc*c;
if(store_left16>1){
store_left16--;
n=store16++;
}
else if(gc_free16!=NULL){
n=gc_free16;
gc_free16=n->header.next;
}
else if(store_left16==1){
store_left16=0;
store_chunk16->header.state_type=FSO_USED_CHUNK;
n=store16++;
}
else{
c=gc_fsoc_get1();
if(gc_free16!=NULL){
n=gc_free16;
gc_free16=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk16=c;
*store_chunk16=H16;
store16=((gc16*)(&(store_chunk16->first_object)));
store_left16=H16.count_minus_one;
n=store16++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M16;
return((T16*)n);
}

void gc_sweep7(fsoc*c){
gc7*o1,*o2,*flt,flh;
o1=((gc7*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store7;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free7;
gc_free7=flh.header.next;
}
}
}

void gc_mark7(T7*o){
se_gc_check_id(o,7);
{if(((gc7*)o)->header.flag==FSOH_UNMARKED){
((gc7*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark9((o->_storage/*1*/));
}
}}

void gc_align_mark7(fsoc*c,gc7*p){
gc7*b=((gc7*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store7)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T7*o=(&(p->object));
((gc7*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_storage/*1*/)gc_mark9((o->_storage/*1*/));
}
}
}
fsoc H7={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark7,
(void(*)(mch*))gc_sweep7},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc7))-1)};

T7*new7(void){
gc7*n;
fsoc*c;
if(store_left7>1){
store_left7--;
n=store7++;
}
else if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else if(store_left7==1){
store_left7=0;
store_chunk7->header.state_type=FSO_USED_CHUNK;
n=store7++;
}
else{
c=gc_fsoc_get1();
if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk7=c;
*store_chunk7=H7;
store7=((gc7*)(&(store_chunk7->first_object)));
store_left7=H7.count_minus_one;
n=store7++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M7;
return((T7*)n);
}

void gc_sweep33(fsoc*c){
gc33*o1,*o2,*flt,flh;
o1=((gc33*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store33;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free33;
gc_free33=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free33;
gc_free33=flh.header.next;
}
}
}

void gc_mark33(T33*o){
se_gc_check_id(o,33);
{((gc33*)o)->header.flag=FSOH_MARKED;

}}

void gc_align_mark33(fsoc*c,gc33*p){
gc33*b=((gc33*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store33)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T33*o=(&(p->object));
((gc33*)o)->header.flag=FSOH_MARKED;
}
}
}
fsoc H33={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark33,
(void(*)(mch*))gc_sweep33},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc33))-1)};

T33*new33(void){
gc33*n;
fsoc*c;
if(store_left33>1){
store_left33--;
n=store33++;
}
else if(gc_free33!=NULL){
n=gc_free33;
gc_free33=n->header.next;
}
else if(store_left33==1){
store_left33=0;
store_chunk33->header.state_type=FSO_USED_CHUNK;
n=store33++;
}
else{
c=gc_fsoc_get1();
if(gc_free33!=NULL){
n=gc_free33;
gc_free33=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk33=c;
*store_chunk33=H33;
store33=((gc33*)(&(store_chunk33->first_object)));
store_left33=H33.count_minus_one;
n=store33++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M33;
return((T33*)n);
}

void gc_mark9(T9 o){
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}

T9 new9(unsigned int size){
size=(size*sizeof(T3))+sizeof(rsoh);
if((size%sizeof(double))!=0)size+=(sizeof(double)-(size%sizeof(double)));
if (size<=(na_env9.store_left)){
rsoh*r=na_env9.store;
na_env9.store_left-=size;
if(na_env9.store_left>sizeof(rsoh)){
r->header.size=size;
na_env9.store=((rsoh*)(((char*)(na_env9.store))+size));
}
else {
r->header.size=size+na_env9.store_left;
na_env9.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T9)(r+1));
}
return((T9)new_na(&na_env9,size));
}

void gc_sweep30(fsoc*c){
gc30*o1,*o2,*flt,flh;
o1=((gc30*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store30;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free30;
gc_free30=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free30;
gc_free30=flh.header.next;
}
}
}

void gc_mark30(T30*o){
se_gc_check_id(o,30);
{if(((gc30*)o)->header.flag==FSOH_UNMARKED){
((gc30*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_uk_addr/*25*/)gc_mark7((T7*)(o->_uk_addr/*25*/));
if(NULL!=o->_us_addr/*17*/)gc_mark7((T7*)(o->_us_addr/*17*/));
if(NULL!=o->_addr/*9*/)gc_mark7((T7*)(o->_addr/*9*/));
if(NULL!=o->_name/*1*/)gc_mark7((T7*)(o->_name/*1*/));
}
}}

void gc_align_mark30(fsoc*c,gc30*p){
gc30*b=((gc30*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store30)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T30*o=(&(p->object));
((gc30*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_uk_addr/*25*/)gc_mark7((T7*)(o->_uk_addr/*25*/));
if(NULL!=o->_us_addr/*17*/)gc_mark7((T7*)(o->_us_addr/*17*/));
if(NULL!=o->_addr/*9*/)gc_mark7((T7*)(o->_addr/*9*/));
if(NULL!=o->_name/*1*/)gc_mark7((T7*)(o->_name/*1*/));
}
}
}
fsoc H30={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark30,
(void(*)(mch*))gc_sweep30},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc30))-1)};

T30*new30(void){
gc30*n;
fsoc*c;
if(store_left30>1){
store_left30--;
n=store30++;
}
else if(gc_free30!=NULL){
n=gc_free30;
gc_free30=n->header.next;
}
else if(store_left30==1){
store_left30=0;
store_chunk30->header.state_type=FSO_USED_CHUNK;
n=store30++;
}
else{
c=gc_fsoc_get1();
if(gc_free30!=NULL){
n=gc_free30;
gc_free30=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk30=c;
*store_chunk30=H30;
store30=((gc30*)(&(store_chunk30->first_object)));
store_left30=H30.count_minus_one;
n=store30++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M30;
return((T30*)n);
}

void gc_sweep27(fsoc*c){
gc27*o1,*o2,*flt,flh;
o1=((gc27*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store27;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free27;
gc_free27=o1;
}
}
}
else{
int dead=1;
flh.header.next=NULL;
flt=&flh;
o2=o1+c->count_minus_one;
for(;o1<=o2;o2--){
if((o2->header.flag)==FSOH_MARKED){
o2->header.flag=FSOH_UNMARKED;
dead=0;}
else{
flt->header.next=o2;
flt=o2;
}
}
if (dead){
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
else if(flh.header.next!=NULL){
flt->header.next=gc_free27;
gc_free27=flh.header.next;
}
}
}

void gc_mark27(T27*o){
se_gc_check_id(o,27);
{if(((gc27*)o)->header.flag==FSOH_UNMARKED){
((gc27*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*5*/)gc_mark9((o->_buffer/*5*/));
}
}}

void gc_align_mark27(fsoc*c,gc27*p){
gc27*b=((gc27*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store27)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T27*o=(&(p->object));
((gc27*)o)->header.flag=FSOH_MARKED;
if(NULL!=o->_buffer/*5*/)gc_mark9((o->_buffer/*5*/));
}
}
}
fsoc H27={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark27,
(void(*)(mch*))gc_sweep27},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc27))-1)};

T27*new27(void){
gc27*n;
fsoc*c;
if(store_left27>1){
store_left27--;
n=store27++;
}
else if(gc_free27!=NULL){
n=gc_free27;
gc_free27=n->header.next;
}
else if(store_left27==1){
store_left27=0;
store_chunk27->header.state_type=FSO_USED_CHUNK;
n=store27++;
}
else{
c=gc_fsoc_get1();
if(gc_free27!=NULL){
n=gc_free27;
gc_free27=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk27=c;
*store_chunk27=H27;
store27=((gc27*)(&(store_chunk27->first_object)));
store_left27=H27.count_minus_one;
n=store27++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M27;
return((T27*)n);
}

#ifdef __cplusplus
}
#endif
